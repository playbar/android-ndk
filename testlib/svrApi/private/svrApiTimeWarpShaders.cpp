//=============================================================================
// FILE: svrApiTimeWarpShaders.cpp
//                  Copyright (c) 2016 QUALCOMM Technologies Inc.
//                              All Rights Reserved.
//
//==============================================================================
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <sched.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <android/native_window.h>

#include "glm/glm.hpp"
#include "glm/gtc/quaternion.hpp"
#include "glm/gtc/type_ptr.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtx/euler_angles.hpp"
#include "glm/gtx/transform.hpp"

#include "svrCpuTimer.h"
#include "svrGpuTimer.h"
#include "svrGeometry.h"
#include "svrProfile.h"
#include "svrShader.h"
#include "svrUtil.h"
#include "svrConfig.h"

#include "private/svrApiCore.h"
#include "private/svrApiHelper.h"
#include "private/svrApiTimeWarp.h"

using namespace Svr;

char svrEyeBufferSeparateVs_Mojing_NoCAC[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"in vec2 texcoord1;     // Eye type , X = 0 = left ; X = 1 = Right\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 4) uniform mat4 overlayMtx;\n"
"layout(location = 5) uniform mat4 overlayMtx2;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordG_overlay;\n"
"out vec2 vTexcoordG_overlay2;\n"
"out vec2 vClipCoord;\n"
"out vec2 vEyeType;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"   float projIZ;\n"
"   // Green\n"
"   vec4 tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"\n"
"   // ******************************\n"
"   // Overlay Coordinates\n"
"   // ******************************\n"
"   // Green\n"
"   tmpTexCoords = overlayMtx * vec4(color, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordG_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordG_overlay = 0.5 * vTexcoordG_overlay + vec2(0.5, 0.5);\n"
"\n"
"   // ******************************\n"
"   // Overlay Coordinates 2\n"
"   // ******************************\n"
"   // Green\n"
"   tmpTexCoords = overlayMtx2 * vec4(color, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordG_overlay2 = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordG_overlay2 = 0.5 * vTexcoordG_overlay2 + vec2(0.5, 0.5);\n"
"\n"
"   vClipCoord =  color;\n"
 "   vEyeType =  texcoord1;\n"
"\n"
"   gl_Position = vec4(position.xy * scaleOffset.xy + scaleOffset.zw, 0.0, 1.0);\n"
"}\n";  // End of shader string

char svrEyeBufferSeparateFs_Mojing_NoCAC[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
// "layout(location = 3) uniform vec2 eyeBorder;\n"
"uniform sampler2D srcTex;\n"
"uniform sampler2D srcTex2;\n"
"uniform sampler2D overlayTex;\n"
"uniform sampler2D overlayTex2;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vTexcoordG_overlay2;\n"
"in vec2 vClipCoord;\n"
"in vec2 vEyeType;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"   vec4 TexColorG;\n"
"   vec4 TexColorG_overlay;\n"
"   if (vEyeType.x < 0.5f)\n"
"   {\n"
"    TexColorG = texture(srcTex, vTexcoordG.xy);\n"
"    TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"    outColor = vec4(mix(TexColorG.rgb, TexColorG_overlay.rgb, TexColorG_overlay.a), 1.0);\n"
"   }\n"
"   else\n"
"   {\n"
"    TexColorG = texture(srcTex2, vTexcoordG.xy);\n"
"    TexColorG_overlay = texture(overlayTex2, vTexcoordG_overlay2.xy);\n"
"    outColor = vec4(mix(TexColorG.rgb, TexColorG_overlay.rgb, TexColorG_overlay.a), 1.0);\n"
"   }\n"
"   }\n"// end of
"\n"
"}\n"
"\n";   // End of shader fs mojing no CAC

char svrEyeBufferSeparateVs_Mojing_NoOverlay[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"in vec2 texcoord1;     // Eye type , X = 0 = left ; X = 1 = Right\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"out vec2 vTexcoordR;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordB;\n"
"out vec2 vClipCoord;\n"
"out vec2 vEyeType;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"   float projIZ;\n"
"   // Red\n"
"   vec4 tmpTexCoords = textureMtx * vec4(normal, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordR = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordR = 0.5 * vTexcoordR + vec2(0.5, 0.5);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = textureMtx * vec4(texcoord0, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordB = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordB = 0.5 * vTexcoordB + vec2(0.5, 0.5);\n"
"\n"
"   vClipCoord =  color;\n"
"   vEyeType =  texcoord1;\n"
"\n"
"   gl_Position = vec4(position.xy * scaleOffset.xy + scaleOffset.zw, 0.0, 1.0);\n"
"}\n";  // End of shader string

char svrEyeBufferSeparateFs_Mojing_NoOverlay[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
// "layout(location = 3) uniform vec2 eyeBorder;\n"
"uniform sampler2D srcTex;\n"
"uniform sampler2D srcTex2;\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordB;\n"
"in vec2 vClipCoord;\n"
"in vec2 vEyeType;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"

"   if (vEyeType.x < 0.5f)\n"
"   {\n"
"    vec4 TexColorR = texture(srcTex, vTexcoordR.xy);\n"
"    vec4 TexColorG = texture(srcTex, vTexcoordG.xy);\n"
"    vec4 TexColorB = texture(srcTex, vTexcoordB.xy);\n"

"    outColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorR.a);\n"
"   }\n"
"   else\n"
"   {\n"
"    vec4 TexColorR = texture(srcTex2, vTexcoordR.xy);\n"
"    vec4 TexColorG = texture(srcTex2, vTexcoordG.xy);\n"
"    vec4 TexColorB = texture(srcTex2, vTexcoordB.xy);\n"

"    outColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorR.a);\n"

"   }\n"
"   }\n"// end of
"\n"
"}\n"
"\n";   // End of shader string

char svrEyeBufferSeparateVs_Mojing[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"in vec2 texcoord1;     // Eye type , X = 0 = left ; X = 1 = Right\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 4) uniform mat4 overlayMtx;\n"
"layout(location = 5) uniform mat4 overlayMtx2;\n"
"out vec2 vTexcoordR;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordB;\n"
"out vec2 vTexcoordR_overlay;\n"
"out vec2 vTexcoordG_overlay;\n"
"out vec2 vTexcoordB_overlay;\n"
"out vec2 vTexcoordR_overlay2;\n"
"out vec2 vTexcoordG_overlay2;\n"
"out vec2 vTexcoordB_overlay2;\n"
"out vec2 vClipCoord;\n"
"out vec2 vEyeType;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"   float projIZ;\n"
"   // Red\n"
"   vec4 tmpTexCoords = textureMtx * vec4(normal, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordR = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordR = 0.5 * vTexcoordR + vec2(0.5, 0.5);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = textureMtx * vec4(texcoord0, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordB = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordB = 0.5 * vTexcoordB + vec2(0.5, 0.5);\n"
"\n"
"   // ******************************\n"
"   // Overlay Coordinates\n"
"   // ******************************\n"
"   // Red\n"
"   tmpTexCoords = overlayMtx * vec4(normal, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordR_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordR_overlay = 0.5 * vTexcoordR_overlay + vec2(0.5, 0.5);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = overlayMtx * vec4(color, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordG_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordG_overlay = 0.5 * vTexcoordG_overlay + vec2(0.5, 0.5);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = overlayMtx * vec4(texcoord0, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordB_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordB_overlay = 0.5 * vTexcoordB_overlay + vec2(0.5, 0.5);\n"
"\n"
"   // ******************************\n"
"   // Overlay Coordinates 2\n"
"   // ******************************\n"
"   // Red\n"
"   tmpTexCoords = overlayMtx2 * vec4(normal, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordR_overlay2 = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordR_overlay2 = 0.5 * vTexcoordR_overlay2 + vec2(0.5, 0.5);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = overlayMtx2 * vec4(color, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordG_overlay2 = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordG_overlay2 = 0.5 * vTexcoordG_overlay2 + vec2(0.5, 0.5);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = overlayMtx2 * vec4(texcoord0, -1.0, 1.0);\n"
"   projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   vTexcoordB_overlay2 = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordB_overlay2 = 0.5 * vTexcoordB_overlay2 + vec2(0.5, 0.5);\n"
"\n"
"   vClipCoord =  color;\n"
 "   vEyeType =  texcoord1;\n"
"\n"
"   gl_Position = vec4(position.xy * scaleOffset.xy + scaleOffset.zw, 0.0, 1.0);\n"
"}\n";  // End of shader string


char svrEyeBufferSeparateFs_Mojing[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
// "layout(location = 3) uniform vec2 eyeBorder;\n"
"uniform sampler2D srcTex;\n"
"uniform sampler2D srcTex2;\n"
"uniform sampler2D overlayTex;\n"
"uniform sampler2D overlayTex2;\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordB;\n"
"in vec2 vTexcoordR_overlay;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vTexcoordB_overlay;\n"
"in vec2 vTexcoordR_overlay2;\n"
"in vec2 vTexcoordG_overlay2;\n"
"in vec2 vTexcoordB_overlay2;\n"
"in vec2 vClipCoord;\n"
"in vec2 vEyeType;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
//"  vec2 eyeBorder = eyeBorderL;\n"
/*"    // Each color channel has a different texture coordinate\n"
"    vec4 TexColorR = texture(srcTex, vec2( clamp( vTexcoordR.x, eyeBorder.x, eyeBorder.y), vTexcoordR.y));\n"
"    vec4 TexColorG = texture(srcTex, vec2( clamp( vTexcoordG.x, eyeBorder.x, eyeBorder.y), vTexcoordG.y));\n"
"    vec4 TexColorB = texture(srcTex, vec2( clamp( vTexcoordB.x, eyeBorder.x, eyeBorder.y), vTexcoordB.y));\n"
"\n"
"    // Combine the colors to get final results\n"
"    outColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorR.a);\n"*/
"   if (vEyeType.x < 0.5f)\n"
"   {\n"
//"     outColor = texture(srcTex, vec2(clamp(vTexcoordG.x, eyeBorder.x, eyeBorder.y), vTexcoordG.y)); \n"
"    vec4 TexColorR = texture(srcTex, vTexcoordR.xy);\n"
"    vec4 TexColorG = texture(srcTex, vTexcoordG.xy);\n"
"    vec4 TexColorB = texture(srcTex, vTexcoordB.xy);\n"
"    vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorR.a);\n"

"    vec4 TexColorR_overlay = texture(overlayTex, vTexcoordR_overlay.xy);\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"    vec4 TexColorB_overlay = texture(overlayTex, vTexcoordB_overlay.xy);\n"
"    vec4 OverlayColor = vec4(TexColorR_overlay.r, TexColorG_overlay.g, TexColorB_overlay.b, TexColorR_overlay.a);\n"
//"    vec4 BaseColor = texture(srcTex, vTexcoordR.xy);\n"
//"    vec4 OverlayColor = texture(overlayTex, vTexcoordR_overlay.xy);\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
// "    outColor = vec4(BaseColor.r, BaseColor.g, BaseColor.b, 1.0);\n"
"   }\n"
"   else\n"
"   {\n"
//"     outColor = texture(srcTex2, vec2( clamp( vTexcoordG.x, eyeBorder.x, eyeBorder.y), vTexcoordG.y));\n"<-- 不叠加Overlay
"    vec4 TexColorR = texture(srcTex2, vTexcoordR.xy);\n"
"    vec4 TexColorG = texture(srcTex2, vTexcoordG.xy);\n"
"    vec4 TexColorB = texture(srcTex2, vTexcoordB.xy);\n"
"    vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorR.a);\n"

"    vec4 TexColorR_overlay = texture(overlayTex2, vTexcoordR_overlay2.xy);\n"
"    vec4 TexColorG_overlay = texture(overlayTex2, vTexcoordG_overlay2.xy);\n"
"    vec4 TexColorB_overlay = texture(overlayTex2, vTexcoordB_overlay2.xy);\n"
"    vec4 OverlayColor = vec4(TexColorR_overlay.r, TexColorG_overlay.g, TexColorB_overlay.b, TexColorR_overlay.a);\n"
//"    vec4 BaseColor = texture(srcTex2, vTexcoordR.xy);\n"
//"    vec4 OverlayColor = texture(overlayTex2, vTexcoordR_overlay2.xy);\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
// "    outColor = vec4(BaseColor.r, BaseColor.g, BaseColor.b, 1.0);\n"
// "    outColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
"   }\n"
"   }\n"// end of
"\n"
"}\n"
"\n";   // End of shader string

// **********************************************
// Debug Blit Shader
// **********************************************
char svrBlitQuadVs[] =
    "#version 300 es\n"
    "in vec2 position;\n"
    "in vec2 texcoord0;\n"
    "layout(location = 1) uniform vec4 scaleOffset;\n"
    "out vec2 vTexcoord0;\n"
    "void main()\n"
    "{\n"
    "	vTexcoord0 = texcoord0;\n"
    "	gl_Position = vec4(position.xy * scaleOffset.xy + scaleOffset.zw, 0.0, 1.0);\n"
    "}\n";  // End of shader string

char svrBlitQuadFs[] =
    "#version 300 es\n"
    "precision highp float;\n"
    "uniform sampler2D srcTex;\n"
    "in vec2 vTexcoord0;\n"
    "out vec4 outColor;\n"
    "void main()\n"
    "{\n"
    "	vec4 srcColor = texture(srcTex, vTexcoord0);\n"
    "	outColor = vec4(srcColor.xyz,srcColor.a);\n"
    "}\n";  // End of shader string

char svrBlitQuadFs_Image[] =
    "#version 300 es\n"
    "\n"
    "#extension GL_OES_EGL_image_external_essl3 : require\n"
    "\n"
    "precision highp float;\n"
    "uniform samplerExternalOES srcTex;\n"
    "in vec2 vTexcoord0;\n"
    "out vec4 outColor;\n"
    "void main()\n"
    "{\n"
    "	vec4 srcColor = texture(srcTex, vTexcoord0);\n"
    "	outColor = vec4(srcColor.xyz,srcColor.a);\n"
    "}\n";  // End of shader string

// **********************************************
// Stencil Shader
// **********************************************
char svrStencilVs[] =
    "#version 300 es\n"
    "in vec3 position;\n"
    "layout(location = 1) uniform vec4 scaleOffset;\n"
    "layout(location = 2) uniform vec4 depthValue;\n"
    "void main()\n"
    "{\n"
    "	gl_Position = vec4(position.xy * scaleOffset.xy + scaleOffset.zw, depthValue.z, 1.0);\n"
    "}\n";  // End of shader string

char svrStencilFs[] =
    "#version 300 es\n"
    "precision highp float;\n"
    "layout(location = 3) uniform vec4 stencilColor;\n"
    "out vec4 outColor;\n"
    "void main()\n"
    "{\n"
    "	outColor = stencilColor;\n"
    "}\n";  // End of shader string

// **********************************************
// Single Render Target for Each Eye (kEyeBufferStereoSeparate)
// **********************************************
char warpShaderSeparateVs[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"out vec2 vTexcoordR;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordB;\n"
"out vec2 vClipCoord;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"	float projIZ;\n"
"   // Red\n"
"   vec4 tmpTexCoords = textureMtx * vec4(normal, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordR = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordR = 0.5 * vTexcoordR + vec2(0.5, 0.5);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = textureMtx * vec4(texcoord0, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordB = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordB = 0.5 * vTexcoordB + vec2(0.5, 0.5);\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + scaleOffset.zw, 0.0, 1.0);\n"
"}\n";  // End of shader string


char warpShaderSeparateFs[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"uniform sampler2D srcTex;\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordB;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"    // Each color channel has a different texture coordinate\n"
"    vec4 TexColorR = texture(srcTex, vTexcoordR.xy);\n"
"    vec4 TexColorG = texture(srcTex, vTexcoordG.xy);\n"
"    vec4 TexColorB = texture(srcTex, vTexcoordB.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    outColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorR.a);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string

// **********************************************
// Single Render Target for Each Eye - Chroma (kEyeBufferStereoSeparate)
// **********************************************
char warpShaderSeparateVs_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vClipCoord;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"	float projIZ;\n"
"\n"
"   // Green\n"
"   vec4 tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + scaleOffset.zw, 0.0, 1.0);\n"
"}\n";  // End of shader string


char warpShaderSeparateFs_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"uniform sampler2D srcTex;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"    // Only have one color since no chromatic aberration \n"
"    vec4 TexColorG = texture(srcTex, vTexcoordG.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    outColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string


// **********************************************
// Single Render Target for Each Eye + Overlay (kEyeBufferStereoSeparate)
// **********************************************
char warpShaderSeparateVs_Overlay[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 5) uniform mat4 overlayMtx;\n"
"out vec2 vTexcoordR;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordB;\n"
"out vec2 vTexcoordR_overlay;\n"
"out vec2 vTexcoordG_overlay;\n"
"out vec2 vTexcoordB_overlay;\n"
"out vec2 vClipCoord;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"	float projIZ;\n"
"\n"
"   // ******************************\n"
"   // Eye Buffer Coordinates\n"
"   // ******************************\n"
"   // Red\n"
"   vec4 tmpTexCoords = textureMtx * vec4(normal, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordR = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordR = 0.5 * vTexcoordR + vec2(0.5, 0.5);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = textureMtx * vec4(texcoord0, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordB = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordB = 0.5 * vTexcoordB + vec2(0.5, 0.5);\n"
"\n"
"   // ******************************\n"
"   // Overlay Coordinates\n"
"   // ******************************\n"
"   // Red\n"
"   tmpTexCoords = overlayMtx * vec4(normal, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordR_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordR_overlay = 0.5 * vTexcoordR_overlay + vec2(0.5, 0.5);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = overlayMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG_overlay = 0.5 * vTexcoordG_overlay + vec2(0.5, 0.5);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = overlayMtx * vec4(texcoord0, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordB_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordB_overlay = 0.5 * vTexcoordB_overlay + vec2(0.5, 0.5);\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + scaleOffset.zw, 0.0, 1.0);\n"
"}\n";  // End of shader string


char warpShaderSeparateFs_Overlay[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"uniform sampler2D srcTex;\n"
"uniform sampler2D overlayTex;\n"
"\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordB;\n"
"in vec2 vTexcoordR_overlay;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vTexcoordB_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"    // Each color channel has a different texture coordinate\n"
"    vec4 TexColorR = texture(srcTex, vTexcoordR.xy);\n"
"    vec4 TexColorG = texture(srcTex, vTexcoordG.xy);\n"
"    vec4 TexColorB = texture(srcTex, vTexcoordB.xy);\n"
"\n"
"    vec4 TexColorR_overlay = texture(overlayTex, vTexcoordR_overlay.xy);\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"    vec4 TexColorB_overlay = texture(overlayTex, vTexcoordB_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorG.a);\n"
"    vec4 OverlayColor = vec4(TexColorR_overlay.r, TexColorG_overlay.g, TexColorB_overlay.b, TexColorB_overlay.a);\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string

// **********************************************
// Single Render Target for Each Eye + Overlay - Chroma (kEyeBufferStereoSeparate)
// **********************************************
char warpShaderSeparateVs_Overlay_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 5) uniform mat4 overlayMtx;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordG_overlay;\n"
"out vec2 vClipCoord;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"	float projIZ;\n"
"\n"
"   // ******************************\n"
"   // Eye Buffer Coordinates\n"
"   // ******************************\n"
"   // Green\n"
"   vec4 tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"\n"
"   // ******************************\n"
"   // Overlay Coordinates\n"
"   // ******************************\n"
"   // Green\n"
"   tmpTexCoords = overlayMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG_overlay = 0.5 * vTexcoordG_overlay + vec2(0.5, 0.5);\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + scaleOffset.zw, 0.0, 1.0);\n"
"}\n";  // End of shader string


char warpShaderSeparateFs_Overlay_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"uniform sampler2D srcTex;\n"
"uniform sampler2D overlayTex;\n"
"\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"    // Only have one color since no chromatic aberration \n"
"    vec4 TexColorG = texture(srcTex, vTexcoordG.xy);\n"
"\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
"    vec4 OverlayColor = vec4(TexColorG_overlay.r, TexColorG_overlay.g, TexColorG_overlay.b, TexColorG_overlay.a);\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string


// **********************************************
// Single Render Target for Each Eye + Image Overlay (kEyeBufferStereoSeparate)
// **********************************************
char warpShaderSeparateFs_ImageOverlay[] =
"#version 300 es\n"
"\n"
"#extension GL_OES_EGL_image_external_essl3 : require\n"
"\n"
"precision highp float;\n"
"\n"
"layout (binding = 1) uniform sampler2D srcTex;\n"
"layout (binding = 0) uniform samplerExternalOES overlayTex;\n"
"\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordB;\n"
"in vec2 vTexcoordR_overlay;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vTexcoordB_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"\n"
"    // Each color channel has a different texture coordinate\n"
"    vec4 TexColorR = texture(srcTex, vTexcoordR.xy);\n"
"    vec4 TexColorG = texture(srcTex, vTexcoordG.xy);\n"
"    vec4 TexColorB = texture(srcTex, vTexcoordB.xy);\n"
"\n"
"    vec4 TexColorR_overlay = texture(overlayTex, vTexcoordR_overlay.xy);\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"    vec4 TexColorB_overlay = texture(overlayTex, vTexcoordB_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorG.a);\n"
"    vec4 OverlayColor = vec4(TexColorR_overlay.r, TexColorG_overlay.g, TexColorB_overlay.b, TexColorB_overlay.a);\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string

// **********************************************
// Single Render Target for Each Eye + Image Overlay - Chroma (kEyeBufferStereoSeparate)
// **********************************************
char warpShaderSeparateFs_ImageOverlay_NoChroma[] =
"#version 300 es\n"
"\n"
"#extension GL_OES_EGL_image_external_essl3 : require\n"
"\n"
"precision highp float;\n"
"\n"
"uniform sampler2D srcTex;\n"
"uniform samplerExternalOES overlayTex;\n"
"\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"\n"
"    // Only have one color since no chromatic aberration \n"
"    vec4 TexColorG = texture(srcTex, vTexcoordG.xy);\n"
"\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
"    vec4 OverlayColor = vec4(TexColorG_overlay.r, TexColorG_overlay.g, TexColorG_overlay.b, TexColorG_overlay.a);\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string


// **********************************************
// Shared Render Target for Both Eyes (kEyeBufferStereoSingle)
// **********************************************
//scaleOffset.z will be 0 for the left eye and 1 for the right eye
char warpShaderSingleVs[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 4) uniform vec4 ipdOffset;\n"
"out vec2 vTexcoordR;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordB;\n"
"out vec2 vClipCoord;\n"
"void main()\n"
"{\n"
"	float projIZ;\n"
"   // Red\n"
"   vec4 tmpTexCoords = textureMtx * vec4(normal, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	tmpTexCoords.xy = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"	vTexcoordR = vec2( (( tmpTexCoords.x * 0.5) + (scaleOffset.z * 0.5)), tmpTexCoords.y);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	tmpTexCoords.xy = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"	vTexcoordG = vec2( (( tmpTexCoords.x * 0.5) + (scaleOffset.z * 0.5)), tmpTexCoords.y);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = textureMtx * vec4(texcoord0, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	tmpTexCoords.xy = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"	vTexcoordB = vec2( (( tmpTexCoords.x * 0.5) + (scaleOffset.z * 0.5)), tmpTexCoords.y);\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + ipdOffset.xy, 0.0, 1.0);\n"
"}\n";  // End of shader string


char warpShaderSingleFs[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"layout(location = 3) uniform vec2 eyeBorder;\n"
"uniform sampler2D srcTex;\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordB;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"    // Each color channel has a different texture coordinate\n"
"    vec4 TexColorR = texture(srcTex, vec2( clamp( vTexcoordR.x, eyeBorder.x, eyeBorder.y), vTexcoordR.y));\n"
"    vec4 TexColorG = texture(srcTex, vec2( clamp( vTexcoordG.x, eyeBorder.x, eyeBorder.y), vTexcoordG.y));\n"
"    vec4 TexColorB = texture(srcTex, vec2( clamp( vTexcoordB.x, eyeBorder.x, eyeBorder.y), vTexcoordB.y));\n"
"\n"
"    // Combine the colors to get final results\n"
"    outColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorR.a);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string

// **********************************************
// Shared Render Target for Both Eyes - Chroma (kEyeBufferStereoSingle)
// **********************************************
//scaleOffset.z will be 0 for the left eye and 1 for the right eye
char warpShaderSingleVs_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 4) uniform vec4 ipdOffset;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vClipCoord;\n"
"void main()\n"
"{\n"
"	float projIZ;\n"
"\n"
"   // Green\n"
"   vec4 tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	tmpTexCoords.xy = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"	vTexcoordG = vec2( (( tmpTexCoords.x * 0.5) + (scaleOffset.z * 0.5)), tmpTexCoords.y);\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + ipdOffset.xy, 0.0, 1.0);\n"
"}\n";  // End of shader string


char warpShaderSingleFs_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"layout(location = 3) uniform vec2 eyeBorder;\n"
"uniform sampler2D srcTex;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"    // Only have one color since no chromatic aberration \n"
"    vec4 TexColorG = texture(srcTex, vec2( clamp( vTexcoordG.x, eyeBorder.x, eyeBorder.y), vTexcoordG.y));\n"
"\n"
"    // Combine the colors to get final results\n"
"    outColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string

// **********************************************
// Shared Render Target for Both Eyes + Overlay (kEyeBufferStereoSingle)
// **********************************************
//scaleOffset.z will be 0 for the left eye and 1 for the right eye
char warpShaderSingleVs_Overlay[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 4) uniform vec4 ipdOffset;\n"
"layout(location = 5) uniform mat4 overlayMtx;\n"
"out vec2 vTexcoordR;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordB;\n"
"out vec2 vTexcoordR_overlay;\n"
"out vec2 vTexcoordG_overlay;\n"
"out vec2 vTexcoordB_overlay;\n"
"out vec2 vClipCoord;\n"
"void main()\n"
"{\n"
"	float projIZ;\n"
"\n"
"   // ******************************\n"
"   // Eye Buffer Coordinates\n"
"   // ******************************\n"
"   // Red\n"
"   vec4 tmpTexCoords = textureMtx * vec4(normal, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	tmpTexCoords.xy = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"	vTexcoordR = vec2( (( tmpTexCoords.x * 0.5) + (scaleOffset.z * 0.5)), tmpTexCoords.y);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	tmpTexCoords.xy = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"	vTexcoordG = vec2( (( tmpTexCoords.x * 0.5) + (scaleOffset.z * 0.5)), tmpTexCoords.y);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = textureMtx * vec4(texcoord0, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	tmpTexCoords.xy = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"	vTexcoordB = vec2( (( tmpTexCoords.x * 0.5) + (scaleOffset.z * 0.5)), tmpTexCoords.y);\n"
"\n"
"   // ******************************\n"
"   // Overlay Coordinates\n"
"   // ******************************\n"
"   // Red\n"
"   tmpTexCoords = overlayMtx * vec4(normal, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	vTexcoordR_overlay = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = overlayMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	vTexcoordG_overlay = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = overlayMtx * vec4(texcoord0, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	vTexcoordB_overlay = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + ipdOffset.xy, 0.0, 1.0);\n"
"}\n";  // End of shader string


char warpShaderSingleFs_Overlay[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"layout(location = 3) uniform vec2 eyeBorder;\n"
"uniform sampler2D srcTex;\n"
"uniform sampler2D overlayTex;\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordB;\n"
"in vec2 vTexcoordR_overlay;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vTexcoordB_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"    // Each color channel has a different texture coordinate\n"
"    vec4 TexColorR = texture(srcTex, vec2( clamp( vTexcoordR.x, eyeBorder.x, eyeBorder.y), vTexcoordR.y));\n"
"    vec4 TexColorG = texture(srcTex, vec2( clamp( vTexcoordG.x, eyeBorder.x, eyeBorder.y), vTexcoordG.y));\n"
"    vec4 TexColorB = texture(srcTex, vec2( clamp( vTexcoordB.x, eyeBorder.x, eyeBorder.y), vTexcoordB.y));\n"
"\n"
"    vec4 TexColorR_overlay = texture(overlayTex, vTexcoordR_overlay.xy);\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"    vec4 TexColorB_overlay = texture(overlayTex, vTexcoordB_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorG.a);\n"
"    vec4 OverlayColor = vec4(TexColorR_overlay.r, TexColorG_overlay.g, TexColorB_overlay.b, TexColorB_overlay.a);\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string

// **********************************************
// Shared Render Target for Both Eyes + Overlay - Chroma (kEyeBufferStereoSingle)
// **********************************************
//scaleOffset.z will be 0 for the left eye and 1 for the right eye
char warpShaderSingleVs_Overlay_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 4) uniform vec4 ipdOffset;\n"
"layout(location = 5) uniform mat4 overlayMtx;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordG_overlay;\n"
"out vec2 vClipCoord;\n"
"void main()\n"
"{\n"
"	float projIZ;\n"
"\n"
"   // ******************************\n"
"   // Eye Buffer Coordinates\n"
"   // ******************************\n"
"\n"
"   // Green\n"
"   vec4 tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	tmpTexCoords.xy = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"	vTexcoordG = vec2( (( tmpTexCoords.x * 0.5) + (scaleOffset.z * 0.5)), tmpTexCoords.y);\n"
"\n"
"   // ******************************\n"
"   // Overlay Coordinates\n"
"   // ******************************\n"
"   // Green\n"
"   tmpTexCoords = overlayMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"   tmpTexCoords.xy = vec2(tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ);\n"
"	vTexcoordG_overlay = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + ipdOffset.xy, 0.0, 1.0);\n"
"}\n";  // End of shader string


char warpShaderSingleFs_Overlay_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"layout(location = 3) uniform vec2 eyeBorder;\n"
"uniform sampler2D srcTex;\n"
"uniform sampler2D overlayTex;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"    // Only have one color since no chromatic aberration \n"
"    vec4 TexColorG = texture(srcTex, vec2( clamp( vTexcoordG.x, eyeBorder.x, eyeBorder.y), vTexcoordG.y));\n"
"\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
"    vec4 OverlayColor = vec4(TexColorG_overlay.r, TexColorG_overlay.g, TexColorG_overlay.b, TexColorG_overlay.a);\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string


// **********************************************
// Shared Render Target for Both Eyes + Image Overlay (kEyeBufferStereoSingle)
// **********************************************
char warpShaderSingleFs_ImageOverlay[] =
"#version 300 es\n"
"\n"
"#extension GL_OES_EGL_image_external_essl3 : require\n"
"\n"
"precision highp float;\n"
"\n"
"layout(location = 3) uniform vec2 eyeBorder;\n"
"uniform sampler2D srcTex;\n"
"uniform samplerExternalOES overlayTex;\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordB;\n"
"in vec2 vTexcoordR_overlay;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vTexcoordB_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"\n"
"    // Each color channel has a different texture coordinate\n"
"    vec4 TexColorR = texture(srcTex, vec2( clamp( vTexcoordR.x, eyeBorder.x, eyeBorder.y), vTexcoordR.y));\n"
"    vec4 TexColorG = texture(srcTex, vec2( clamp( vTexcoordG.x, eyeBorder.x, eyeBorder.y), vTexcoordG.y));\n"
"    vec4 TexColorB = texture(srcTex, vec2( clamp( vTexcoordB.x, eyeBorder.x, eyeBorder.y), vTexcoordB.y));\n"
"\n"
"    vec4 TexColorR_overlay = texture(overlayTex, vTexcoordR_overlay.xy);\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"    vec4 TexColorB_overlay = texture(overlayTex, vTexcoordB_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorG.a);\n"
"    vec4 OverlayColor = vec4(TexColorR_overlay.r, TexColorG_overlay.g, TexColorB_overlay.b, TexColorB_overlay.a);\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string


// **********************************************
// Shared Render Target for Both Eyes + Image Overlay - Chroma (kEyeBufferStereoSingle)
// **********************************************
char warpShaderSingleFs_ImageOverlay_NoChroma[] =
"#version 300 es\n"
"\n"
"#extension GL_OES_EGL_image_external_essl3 : require\n"
"\n"
"precision highp float;\n"
"\n"
"layout(location = 3) uniform vec2 eyeBorder;\n"
"uniform sampler2D srcTex;\n"
"uniform samplerExternalOES overlayTex;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if( vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f ) { discard; }\n"
"    else {\n"
"\n"
"    // Only have one color since no chromatic aberration \n"
"    vec4 TexColorG = texture(srcTex, vec2( clamp( vTexcoordG.x, eyeBorder.x, eyeBorder.y), vTexcoordG.y));\n"
"\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
"    vec4 OverlayColor = vec4(TexColorG_overlay.r, TexColorG_overlay.g, TexColorG_overlay.b, TexColorG_overlay.a);\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string


// **********************************************
// Array Render Target with Layer for Each Eye (kEyeBufferArray)
// **********************************************
char warpShaderArrayVs[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 4) uniform vec4 ipdOffset;\n"
"out vec2 vTexcoordR;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordB;\n"
"out vec2 vClipCoord;\n"
"out float whichTexLayer;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"	float projIZ;\n"
"   // Red\n"
"   vec4 tmpTexCoords = textureMtx * vec4(normal, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordR = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordR = 0.5 * vTexcoordR + vec2(0.5, 0.5);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = textureMtx * vec4(texcoord0, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordB = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordB = 0.5 * vTexcoordB + vec2(0.5, 0.5);\n"
"\n"
"   // Which texture layer (Left or Right side of screen)\n"
"   whichTexLayer = scaleOffset.z;\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + ipdOffset.zw, 0.0, 1.0);\n"
"}\n";  // End of shader string


//Fragment shader used to warp eye buffers coming in as a sampler2DArray
char warpShaderArrayFs[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"uniform sampler2DArray srcTex;\n"
"\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordB;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if (vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f) { discard;} \n"
"    else {\n"
"    // Each color channel has a different texture coordinate\n"
"    vec4 TexColorR = texture(srcTex, vec3(vTexcoordR, whichTexLayer));\n"
"    vec4 TexColorG = texture(srcTex, vec3(vTexcoordG, whichTexLayer));\n"
"    vec4 TexColorB = texture(srcTex, vec3(vTexcoordB, whichTexLayer));\n"
"\n"
"    // Combine the colors to get final results\n"
"    outColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorR.a);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string

// **********************************************
// Array Render Target with Layer for Each Eye - Chroma (kEyeBufferArray)
// **********************************************
char warpShaderArrayVs_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 4) uniform vec4 ipdOffset;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vClipCoord;\n"
"out float whichTexLayer;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"	float projIZ;\n"
"\n"
"   // Green\n"
"   vec4 tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"\n"
"   // Which texture layer (Left or Right side of screen)\n"
"   whichTexLayer = scaleOffset.z;\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + ipdOffset.zw, 0.0, 1.0);\n"
"}\n";  // End of shader string


//Fragment shader used to warp eye buffers coming in as a sampler2DArray
char warpShaderArrayFs_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"uniform sampler2DArray srcTex;\n"
"\n"
"in vec2 vTexcoordG;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if (vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f) { discard;} \n"
"    else {\n"
"    // Only have one color since no chromatic aberration \n"
"    vec4 TexColorG = texture(srcTex, vec3(vTexcoordG, whichTexLayer));\n"
"\n"
"    // Combine the colors to get final results\n"
"    outColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string


// **********************************************
// Array Render Target with Layer for Each Eye + Overlay (kEyeBufferArray)
// **********************************************
char warpShaderArrayVs_Overlay[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 4) uniform vec4 ipdOffset;\n"
"layout(location = 5) uniform mat4 overlayMtx;\n"
"out vec2 vTexcoordR;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordB;\n"
"out vec2 vTexcoordR_overlay;\n"
"out vec2 vTexcoordG_overlay;\n"
"out vec2 vTexcoordB_overlay;\n"
"out vec2 vClipCoord;\n"
"out float whichTexLayer;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"	float projIZ;\n"
"\n"
"   // ******************************\n"
"   // Eye Buffer Coordinates\n"
"   // ******************************\n"
"   // Red\n"
"   vec4 tmpTexCoords = textureMtx * vec4(normal, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordR = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordR = 0.5 * vTexcoordR + vec2(0.5, 0.5);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = textureMtx * vec4(texcoord0, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordB = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordB = 0.5 * vTexcoordB + vec2(0.5, 0.5);\n"
"\n"
"   // ******************************\n"
"   // Overlay Coordinates\n"
"   // ******************************\n"
"   // Red\n"
"   tmpTexCoords = overlayMtx * vec4(normal, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordR_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordR_overlay = 0.5 * vTexcoordR_overlay + vec2(0.5, 0.5);\n"
"\n"
"   // Green\n"
"   tmpTexCoords = overlayMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG_overlay = 0.5 * vTexcoordG_overlay + vec2(0.5, 0.5);\n"
"\n"
"   // Blue\n"
"   tmpTexCoords = overlayMtx * vec4(texcoord0, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordB_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordB_overlay = 0.5 * vTexcoordB_overlay + vec2(0.5, 0.5);\n"
"\n"
"   // Which texture layer (Left or Right side of screen)\n"
"   whichTexLayer = scaleOffset.z;\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + ipdOffset.zw, 0.0, 1.0);\n"
"}\n";  // End of shader string


char warpShaderArrayFs_Overlay[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"uniform sampler2DArray srcTex;\n"
"uniform sampler2D overlayTex;\n"
"\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordB;\n"
"in vec2 vTexcoordR_overlay;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vTexcoordB_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if (vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f) { discard;} \n"
"    else {\n"
"\n"
"    // Each color channel has a different texture coordinate\n"
"    vec4 TexColorR = texture(srcTex, vec3(vTexcoordR, whichTexLayer));\n"
"    vec4 TexColorG = texture(srcTex, vec3(vTexcoordG, whichTexLayer));\n"
"    vec4 TexColorB = texture(srcTex, vec3(vTexcoordB, whichTexLayer));\n"
"\n"
"    vec4 TexColorR_overlay = texture(overlayTex, vTexcoordR_overlay.xy);\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"    vec4 TexColorB_overlay = texture(overlayTex, vTexcoordB_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorG.a);\n"
"\n"
"    vec4 OverlayColor = vec4(TexColorR_overlay.r, TexColorG_overlay.g, TexColorB_overlay.b, TexColorB_overlay.a);\n"
"\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string

// **********************************************
// Array Render Target with Layer for Each Eye + Overlay - Chroma (kEyeBufferArray)
// **********************************************
char warpShaderArrayVs_Overlay_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"in vec2 position;      // Position\n"
"in vec2 normal;        // Red\n"
"in vec2 color;         // Green\n"
"in vec2 texcoord0;     // Blue\n"
"layout(location = 1) uniform vec4 scaleOffset;\n"
"layout(location = 2) uniform mat4 textureMtx;\n"
"layout(location = 4) uniform vec4 ipdOffset;\n"
"layout(location = 5) uniform mat4 overlayMtx;\n"
"out vec2 vTexcoordG;\n"
"out vec2 vTexcoordG_overlay;\n"
"out vec2 vClipCoord;\n"
"out float whichTexLayer;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"	float projIZ;\n"
"\n"
"   // ******************************\n"
"   // Eye Buffer Coordinates\n"
"   // ******************************\n"
"   // Green\n"
"   vec4 tmpTexCoords = textureMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"\n"
"   // ******************************\n"
"   // Overlay Coordinates\n"
"   // ******************************\n"
"   // Green\n"
"   tmpTexCoords = overlayMtx * vec4(color, -1.0, 1.0);\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG_overlay = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"	vTexcoordG_overlay = 0.5 * vTexcoordG_overlay + vec2(0.5, 0.5);\n"
"\n"
"   // Which texture layer (Left or Right side of screen)\n"
"   whichTexLayer = scaleOffset.z;\n"
"\n"
"   vClipCoord =  color;\n"
"\n"
"	gl_Position = vec4(position.xy * scaleOffset.xy + ipdOffset.zw, 0.0, 1.0);\n"
"}\n";  // End of shader string


char warpShaderArrayFs_Overlay_NoChroma[] =
"#version 300 es\n"
"\n"
"precision highp float;\n"
"\n"
"uniform sampler2DArray srcTex;\n"
"uniform sampler2D overlayTex;\n"
"\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if (vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f) { discard;} \n"
"    else {\n"
"\n"
"    // Only have one color since no chromatic aberration \n"
"    vec4 TexColorG = texture(srcTex, vec3(vTexcoordG, whichTexLayer));\n"
"\n"
"    // vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
"\n"
"    vec4 OverlayColor = vec4(TexColorG_overlay.r, TexColorG_overlay.g, TexColorG_overlay.b, TexColorG_overlay.a);\n"
"\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string


// **********************************************
// Array Render Target with Layer for Each Eye + Image Overlay (kEyeBufferArray)
// **********************************************
char warpShaderArrayFs_ImageOverlay[] =
"#version 300 es\n"
"\n"
"#extension GL_OES_EGL_image_external_essl3 : require\n"
"\n"
"precision highp float;\n"
"\n"
"uniform sampler2DArray srcTex;\n"
"uniform samplerExternalOES overlayTex;\n"
"\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordB;\n"
"in vec2 vTexcoordR_overlay;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vTexcoordB_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if (vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f) { discard;} \n"
"    else {\n"
"\n"
"    // Each color channel has a different texture coordinate\n"
"    vec4 TexColorR = texture(srcTex, vec3(vTexcoordR, whichTexLayer));\n"
"    vec4 TexColorG = texture(srcTex, vec3(vTexcoordG, whichTexLayer));\n"
"    vec4 TexColorB = texture(srcTex, vec3(vTexcoordB, whichTexLayer));\n"
"\n"
"    vec4 TexColorR_overlay = texture(overlayTex, vTexcoordR_overlay.xy);\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"    vec4 TexColorB_overlay = texture(overlayTex, vTexcoordB_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorG.a);\n"
"\n"
"    vec4 OverlayColor = vec4(TexColorR_overlay.r, TexColorG_overlay.g, TexColorB_overlay.b, TexColorB_overlay.a);\n"
"\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string

// **********************************************
// Array Render Target with Layer for Each Eye + Image Overlay - Chroma (kEyeBufferArray)
// **********************************************
char warpShaderArrayFs_ImageOverlay_NoChroma[] =
"#version 300 es\n"
"\n"
"#extension GL_OES_EGL_image_external_essl3 : require\n"
"\n"
"precision highp float;\n"
"\n"
"uniform sampler2DArray srcTex;\n"
"uniform samplerExternalOES overlayTex;\n"
"\n"
"in vec2 vTexcoordG;\n"
"in vec2 vTexcoordG_overlay;\n"
"in vec2 vClipCoord;\n"
"in float whichTexLayer;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    if (vClipCoord.x < -1.0 || vClipCoord.x > 1.0 || vClipCoord.y < -1.0f || vClipCoord.y > 1.0f) { discard;} \n"
"    else {\n"
"\n"
"    // Only have one color since no chromatic aberration \n"
"    vec4 TexColorG = texture(srcTex, vec3(vTexcoordG, whichTexLayer));\n"
"\n"
"    vec4 TexColorG_overlay = texture(overlayTex, vTexcoordG_overlay.xy);\n"
"\n"
"    // Combine the colors to get final results\n"
"    vec4 BaseColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
"\n"
"    vec4 OverlayColor = vec4(TexColorG_overlay.r, TexColorG_overlay.g, TexColorG_overlay.b, TexColorG_overlay.a);\n"
"\n"
"    outColor = vec4(mix(BaseColor.rgb, OverlayColor.rgb, OverlayColor.a), 1.0);\n"
"    }\n"
"\n"
"}\n"
"\n";   // End of shader string

